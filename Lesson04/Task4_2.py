import cProfile

# классический алгоритм с проверкой возможности деления анализируемого числа на предыдущие простые числа
def simple(n):
    # функция возвращает n-ое по счёту простое число
    # простые числа делятся только на себя и единицу. 2 - первое простое число
    a = [2]
    i = 3  # проверку начинаем с числа 3, оно же будет 2-ым элементом
    while len(a) < n:  # нам надо найти простое число номер n
        j = 0 # это индекс простого числа в массиве уже найденных простых чисел
        # пока остаток от деления на предыдущие простые числа не равен 0 и мы не дошли до конца массива
        # проверяем делимость числа на все найденные простые числа
        while (j < len(a)) and (i % a[j]):
            j +=1
        if (j == len(a)):
            a.append(i)
        # переходим к следующему анализируемому числу
        i += 1
    return a[-1] if n > 1 else a[0]


# классический алгоритм Эратосфена с вычёркиванием кратных чисел из всего массива
def eratosphen_classic(n):
    # функция возвращает n-ое по счёту простое число
    # 2 - первое простое число
    if n < 2: return 2
    # Создание и заполнение списка чисел из интервала [0; n**2]. простое число номер n лежит в диапазоне до n в квадрате
    a = [i for i in range(0, n ** 2)]
    # итоговый Список простых чисел
    b = []
    # Перебор всех чисел от 2 до n.
    for i in range(2, len(a)):
        # если i-тое рассматриваемое число не рано нулю, значит оно простое. Добавляем в результирующий массив
        if a[i] != 0: b.append(a[i])
        # как только длина массива простых чисел сравнялась с n, возвращаем последнее простое число
        if len(b) == n: return b[-1]
        # Перебрать все кратные i числа в нашем диапазоне и пометить их 0.
        for j in range(i * 2, len(a), i):
                a[j] = 0


# сложность алгоритма Эратосфена составляет O(n*Log(log(n))), так как мы для каждого числа из множества целых чисел
# вычеркиваем непростые числа при этом проходим по всем числам от анализируемого числа до конца списка.

# сложность арифмитического алгоритма составляет O(N), так как нам надо проверить делимость каждого числа на все
# найденные простые числа. кол-во выполняемых итераций гораздо меньше по сравненению с алгоритмом эратосфена

#cProfile.run('simple(10)')
#         1    0.001    0.001    0.001    0.001 Task4_2.py:4(simple)
#cProfile.run('eratosphen_classic(10)')
#         1    0.000    0.000    0.000    0.000 Task4_2.py:23(eratosphen_classic)
#cProfile.run('simple(100)')
#         1    0.002    0.002    0.002    0.002 Task4_2.py:4(simple)
#cProfile.run('eratosphen_classic(100)')
#         1    0.003    0.003    0.004    0.004 Task4_2.py:23(eratosphen_classic)
#cProfile.run('simple(1000)')
#         1    0.138    0.138    0.174    0.174 Task4_2.py:4(simple)
#cProfile.run('eratosphen_classic(1000)')
#         1    0.565    0.565    0.622    0.622 Task4_2.py:23(eratosphen_classic)
#cProfile.run('simple(10000)')
#         1   15.560   15.560   19.033   19.033 Task4_2.py:4(simple)
#cProfile.run('eratosphen_classic(10000)')
#         1    0.000    0.000  112.971  112.971 {built-in method builtins.exec}

# "Task4_2.simple(100)"   10 loops, best of 5: 1.06 msec per loop
# "Task4_2.simple(1000)"  10 loops, best of 5: 103 msec per loop
# "Task4_2.simple(10000)" 10 loops, best of 5: 10.3 sec per loop

# "Task4_2.eratosphen_classic(100)"  10 loops, best of 5: 3.32 msec per loop
# "Task4_2.eratosphen_classic(1000)"  10 loops, best of 5: 604 msec per loop
# "Task4_2.eratosphen_classic(10000)" 10 loops, best of 5: 102.3 sec per loop