"""
Для оценки «Отлично» необходимо выполнить оба задания.
Задача считается решённой, если в ней использована как минимум одна коллекция из модуля collections.

2. Написать программу сложения и умножения двух шестнадцатеричных чисел. При этом каждое число представляется
как массив, элементы которого — цифры числа.
Например, пользователь ввёл A2 и C4F. Нужно сохранить их как [‘A’, ‘2’] и [‘C’, ‘4’, ‘F’] соответственно.
Сумма чисел из примера: [‘C’, ‘F’, ‘1’], произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].
Примечание: Если воспользоваться функциями hex() и/или int() для преобразования систем счисления,
задача решается в несколько строк. Для прокачки алгоритмического мышления такой вариант не подходит.
Поэтому использование встроенных функций для перевода из одной системы счисления в другую в данной задаче под запретом.

"""
from collections import deque

first = input('Введите первое шестнадцетеричное число: ')
second = input('Введите второе шестнадцетеричное число: ')
# создаём список из элементов 16-ричной системы
list_of_numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']



# Сравниваем строки и выбираем большую для итераций по её символам.
if len(first) > len(second):
  first, second = second, first

# Переворачиваем выбранную строку
second = second[::-1]

# очередь результата сложения
third_add = deque()


# Для операции умножения будем использовать очереди. создадим две очереди на основе введённых строк-чисел
first_deque = deque(first)
second_deque = deque(second)

# Создаём вспомагательные переменные и запускаем цикл по большей строке.
# В нём находим индексы соответствующих элементов первой и второй строк в созданном ранее списке
# символов 16-ричной системы. Если у нас есть переход в другой разряд, то прибавляем k = 1, если нет, то k = 0.
# Чтоб не вывалится за границы, берём остаток от деления. C той же целью введён break.
j = -1
k = 0
for i in second:
  one = list_of_numbers.index(second_deque.popleft())
  two = list_of_numbers.index(first_deque.pop())
  third_add.appendleft(list_of_numbers[(one + two + k) % 16])
  if (one + two) >= 15:
    k = 1
  else:
    k = 0
  j -= 1
  if j == -len(first)-1:
    break

# Как только цикл закончен, проверям, отличались ли у нас вообще числа. Если да, то проходим по оставшимся
# символам большей строки и прибавляем их.  Тут нам приходится та же переменная k.
# Ведь могло быть такое, что последний элемент последней итерации предыдущего цикла перешёл в другой разряд.
# Мы это и учитываем благодаря переменной k.

diff = len(second) - len(first)

if diff:
    for i in second[-diff:]:
        third_add.appendleft(list_of_numbers[(list_of_numbers.index(i) + k) % 16])
        if list_of_numbers.index(i) + 1 >= 15:
            k = 1
        else:
            k = 0

# Ну и если после последний итерации этого цикла у нас число перешло в другой разряд, то просто добавляем ещё одну еденицу.

if k == 1:
  third_add.appendleft('1')

# печатаем очередь c результатом сложения
print(third_add)


#*************************************

# очередь результата умножения
third_mul = deque()

# Для операции умножения будем использовать очередь и список.
first_deque = deque(first)

k = 0
for i in first:
    two = list_of_numbers.index(first_deque.pop())
    for j in second:
# очередь использовать не получится, так как надо пройтись по массиву несколько раз
        one = list_of_numbers.index(j)
        third_mul.appendleft(list_of_numbers[(one * two + k) % 16])
        if (one * two + k) >= 15:
            k = (one * two + k) // 16
        else:
            k = 0

# Ну и если после последний итерации этого цикла у нас число перешло в другой разряд, то просто добавляем эти разряды.

if k:
  third_mul.appendleft(list_of_numbers[k])


# печатаем очередь c результатом умножения
print(third_mul)


